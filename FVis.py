import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable, axes_size
import matplotlib.animation
import os, sys, time, datetime, struct


' *** For Windows users: Specify path to ffmpeg (required for saving animations) *** '

#plt.rcParams['animation.ffmpeg_path'] = r'<My path to ffmpeg folder>\ffmpeg\bin\ffmpeg'


class FluidVisualiser:

	'Class containing methods for visualising data generated by a fluid simulation.'

	def __init__(self, printInfo=True):

		self.printInfo = printInfo
		self.hasSaved = False

	def save_data(self, sim_time, update_func, rho=None, u=None, w=None, e=None, P=None, T=None, Lx=None, Lz=None, sim_params=None, t_init=0, fps=1, useDblPrec=False, folder='auto'):

		'''
		Advances the simulation by a given amount of time 
		and saves the relevant data to binary files.
		'''

		# *** Make sure that all the input is valid ***

		arr_names = ['rho', 'u', 'w', 'e', 'P', 'T']
		has_arr = []
		input_arrs = {}

		for arr, name in zip([rho, u, w, e, P, T], arr_names):

			has_arr.append(not (arr is None))
			if not (arr is None): input_arrs[name] = arr

		if not True in has_arr:

			print 'FluidVisualiser: No arrays to write. Aborting ...'
			sys.exit()

		arr_dim = len(input_arrs.values()[0].shape) # Number of dimensions for simulation
		arr_shape = input_arrs.values()[0].shape 	# Shape of the data blocks to write

		# Loop through array dict and make sure that the provded arrays have the right type and shape

		for name, arr in input_arrs.iteritems():

			if not isinstance(arr, np.ndarray): raise TypeError('Input array \"%s\" has type %s. Must be a numpy array.' % (name, type(arr)))

		for arr in input_arrs.values():

			if len(arr.shape) != arr_dim: raise ValueError('Dimensions of input arrays don\'t match.')

		for arr in input_arrs.values():

			if arr.shape != arr_shape: raise ValueError('Shapes of input arrays don\'t match.')

		# Check that the other arguments have the right type
		try:

			sim_time = float(sim_time)
			fps = float(fps)
			folder = str(folder)

		except ValueError:

			raise ValueError('Invalid type for simulation time, fps or folder name.')

		if not hasattr(update_func, '__call__'): raise TypeError('Input argument \"update_func\" must be a function or method.')
		if not (sim_params is None) and not isinstance(sim_params, dict): raise TypeError('Input argument \"sim_params\" must be a dictionary.')
		
		for name in sim_params:

			if not isinstance(name, str): raise TypeError('Keys in \'sim_params\' must be strings.')


		if self.printInfo: print '\nFluidVisualiser: Simulating %g seconds and saving %g frames per second to binary files ...\n' % (sim_time, fps)


		# *** Create output folder ***

		# Create a string of the current date and time (or use a user specified name)
		now = datetime.datetime.now()
		self.folder = folder if folder != 'auto' else ('FVis_output_' + now.strftime('%Y-%m-%d_%H-%M'))

		# Use the string to create a unique folder and make it the current working directory

		cwd = os.getcwd()
		self.newfolder_count = 0

		def create_folder():

			try:

				os.mkdir(self.folder)

			except OSError as e:

				if self.newfolder_count < 5:

					self.folder += '_new'
					self.newfolder_count += 1
					create_folder()

				else:

					raise OSError(e)

		# Keep adding _new to the name until it is unique
		create_folder()

		newdirpath = os.path.join(cwd, self.folder)
		os.chdir(newdirpath)


		# *** Initialize writer object instances ***

		# Data type to write
		dtype = 'f8' if useDblPrec else 'f4'

		# Create instances of the _BinWriter class for writing the data

		arr_writers = {}

		for name in input_arrs:

			arr_writers[name] = _BinWriter(name + '.pas', arr_shape, dtype)

		time_writer = _BinWriter('time.pas', (2,), dtype)


		# *** Write data ***

		# Write the initial data to the files
		for name in input_arrs:

			arr_writers[name].write_block(input_arrs[name])

		time_writer.write_block([t_init, 0])

		# Approximate time between each frame to save
		t_skip = 1.0/fps
		elapsed_time = 0

		# Start measuring elapsed time
		start_time = time.time()

		while elapsed_time < sim_time:

			try:

				# Run an appropriate number of simulation steps

				t = t_init
				t0 = t
				skips = 0

				while t - t0 < t_skip:

					t += update_func()
					skips += 1

				dt_avg = (t - t0)/skips

				elapsed_time += t

				# Write the current data to the files

				for name in input_arrs:

					arr_writers[name].write_block(input_arrs[name])

				time_writer.write_block([dt_avg, skips])

				# Print progress
				if self.printInfo: FluidVisualiser.__print_progress(elapsed_time, sim_time, start_time)

			# If aborted by user, exit the loop and finish up the writing
			except KeyboardInterrupt:

				if self.printInfo: print '\nFluidVisualiser: Writing interrupted by user. Aborting ...'

				break

			except TypeError:

				raise TypeError('Input argument \'update_func\' must return the time step length (and nothing else).')

		if self.printInfo: print

		# Close files
		for name in input_arrs:

			arr_writers[name].end_write(printReport=self.printInfo)

		time_writer.end_write(printReport=self.printInfo)

		# Write simulation parameters to a text file

		info = ''

		if not (Lx is None) and not (u is None): info += 'Lx = %g\n' % Lx
		if not (Lz is None) and not (w is None): info += 'Lz = %g\n' % Lz

		for i in xrange(len(arr_names)):

			info += 'has_%s = %d\n' % (arr_names[i], has_arr[i])

		def try_convert(val):

			try:

				newval = '%g' % val

			except TypeError:

				newval = str(val)

			return newval

		if not (sim_params is None):

			for name in sorted(sim_params):

				info += name + ' = ' + try_convert(sim_params[name]) + '\n'

		f = open('info.txt', 'w')
		f.write(info[:-1])
		f.close()

		# Return to original working directory
		os.chdir(cwd)

		if self.printInfo: print '\nFluidVisualiser: Data stored in folder \"%s\".' % self.folder

		# Indicate that data was saved in this instance
		self.hasSaved = True

	def animate_1D(self, quantity, folder='default', height=7, fps=1, showDeviations=True, save=False, video_time='auto', aspect=1.1, title='auto'):

		'Creates a 1D animation of the time evolution.'

		# *** Make sure that the inputted values are valid ***

		try:

			quantity = str(quantity)
			folder = str(folder)
			height = float(height)
			fps = float(fps)
			if video_time != 'auto': video_time = float(video_time)
			if aspect != 'auto': aspect = float(aspect)
			title = str(title)

		except ValueError:

			raise ValueError('Invalid type detected among the inputted parameters.')


		# *** Check which folder to use ***

		if folder == 'default':

			if self.hasSaved:

				folder = self.folder

			else:

				raise ValueError('Name of the folder to read from must be specified unless save_data was used with this instance.')


		# *** Prepare figure ***

		# Get information required for displaying the given quantity
		self.__read_header_data(folder, forcedim=1)
		q, name, unit = self.__get_quantity_info(quantity)
		min_val, max_val = self.__get_optimal_scaling(q, includeAll=True)

		if self.printInfo: print 'FluidVisualiser: Preparing figure ...'

		# Define figure and axis
		fig = plt.figure(figsize=(height*aspect, height))
		ax = fig.add_subplot(111)

		# Create plot for fluid
		line, = ax.plot(self.l, q())

		# Add figure info
		textbox1, textbox2, textbox3 = self.__prepare_text(ax, dim=1)
		
		# Set axis limits and labels

		if self.direction == 'z':

			ax.set_xlim(-self.extent, 0)

		else:

			ax.set_xlim(0, self.extent)

		ax.set_ylim(min_val, max_val)
		ax.set_xlabel(self.direction + ' [Mm]')
		ax.set_ylabel(quantity + ('' if unit == '' else ' [%s]' % unit))
		ax.set_title((name[0].upper() + name[1:]) if title == 'auto' else title)


		# *** Define function for updating animation ***

		t_skip = 1.0/fps 	 # Time between each frame to render
		Nt = int(np.floor(((self.t_list[-1] - self.t_list[0]) if video_time == 'auto' else video_time)*fps)) # Total number of frames

		# Initial values of total mass and energy density
		if self.has_arr['rho']: rho_tot0 = np.sum(self.arrs['rho'])
		if self.has_arr['e']: e_tot0 = np.sum(self.arrs['e'])

		def update(i):

			# Run an appropriate number of simulation steps
			dt_avg = self.__step_time(t_skip)

			# Update fluid image data
			line.set_ydata(q())

			# Update text

			textbox1.set_text('Time: %s\ndt = %.2g s' % (FluidVisualiser.__s_to_hms(self.t), dt_avg))

			if showDeviations:

				devi_text = ''
				if self.has_arr['rho']: devi_text += 'Mass deviation: %.3f %%' % (100*(np.sum(self.arrs['rho'].astype('f8'))/rho_tot0 - 1.0))
				if self.has_arr['e']: devi_text += '\nEnergy deviation: %.3f %%' % (100*(np.sum(self.arrs['e'].astype('f8'))/e_tot0 - 1.0))

				textbox2.set_text(devi_text)

			textbox3.set_text(self.param_text)

			# Print progress if generating a movie
			if save: FluidVisualiser.__print_progress(i, Nt, t0)

			# Return figure content
			return line, textbox1, textbox2, textbox3


		# *** Create animation ***

		if save:

			savename = '%s.mp4' % folder

			if self.printInfo: print 'FluidVisualiser: Generating animation ...\n'

			animation = matplotlib.animation.FuncAnimation(fig, update, blit=True, frames=Nt)

			t0 = time.time()

			animation.save(savename, writer=matplotlib.animation.FFMpegWriter(fps=30, bitrate=3200, extra_args=['-vcodec', 'libx264']))

			if self.printInfo: print '\n\nFluidVisualiser: Animation saved as \"%s\".' % savename

		else:

			if self.printInfo: print 'FluidVisualiser: Playing animation ...'

			animation = matplotlib.animation.FuncAnimation(fig, update, blit=True)
			plt.show()

	def animate_2D(self, quantity, folder='default', matrixLike=True, height=7, fps=1, showDeviations=True, showQuiver=True, quiverscale=1, N_arrows=20, save=False, video_time='auto', aspect='equal', title='auto', interpolation='none', cmap='jet'):

		'Creates an animation of the time evolution.'

		# *** Make sure that the inputted values are valid ***

		try:

			quantity = str(quantity)
			folder = str(folder)
			height = float(height)
			fps = float(fps)
			quiverscale = float(quiverscale)
			N_arrows = int(N_arrows)
			if video_time != 'auto': video_time = float(video_time)
			if aspect != 'equal': aspect = float(aspect)
			title = str(title)
			interpolation = str(interpolation)

		except ValueError:

			raise ValueError('Invalid type detected among the inputted parameters.')


		# *** Check which folder to use ***

		if folder == 'default':

			if self.hasSaved:

				folder = self.folder

			else:

				raise ValueError('Name of the folder to read from must be specified unless save_data was used with this instance.')


		# *** Prepare figure ***

		# Get information required for displaying the given quantity
		self.__read_header_data(folder, forcedim=2, matrixLike=matrixLike)
		q, name, unit = self.__get_quantity_info(quantity)
		min_val, max_val = self.__get_optimal_scaling(q)

		if self.printInfo: print 'FluidVisualiser: Preparing figure ...'

		aspect = self.equal_aspect if aspect == 'equal' else float(aspect)

		# Define figure and axis
		fig = plt.figure(figsize=(height*aspect, height))
		ax = fig.add_subplot(111)

		# Create image for fluid
		img = ax.imshow(q() if matrixLike else q().T, origin='lower', norm=plt.Normalize(min_val, max_val),
							 cmap=plt.get_cmap(cmap), interpolation=interpolation, 
							 extent=[0, self.extent_x, -self.extent_z, 0], aspect='auto',
							 animated=True)

		# Create quiver plot
		if not (self.has_arr['u'] and self.has_arr['w']): showQuiver = False
		step_q, quiver = self.__get_quiver(ax, N_arrows, quiverscale, showQuiver)

		# Add figure info
		textbox1, textbox2, textbox3 = self.__prepare_text(ax)
		
		# Set axis limits and labels
		ax.set_xlim(0, self.extent_x)
		ax.set_ylim(-self.extent_z, 0)
		ax.set_xlabel('x [Mm]')
		ax.set_ylabel('z [Mm]')
		ax.set_title((name[0].upper() + name[1:]) if title == 'auto' else title, y=1.05)

		# Display colorbar
		width = axes_size.AxesY(ax, aspect=0.07)
		pad = axes_size.Fraction(0.4, width)
		divider = make_axes_locatable(ax)
		cax = divider.append_axes('right', size=width, pad=pad)
		fig.colorbar(img, cax=cax, label=(quantity + ('' if unit == '' else ' [%s]' % unit)))

		# Remove unnecessary figure space
		if self.Nx >= self.Nz: fig.tight_layout(pad=(1 if save else 5))


		# *** Define function for updating animation ***

		t_skip = 1.0/fps 	 # Time between each frame to render
		Nt = int(np.floor(((self.t_list[-1] - self.t_list[0]) if video_time == 'auto' else video_time)*fps)) # Total number of frames

		# Initial values of total mass and energy density
		if self.has_arr['rho']: rho_tot0 = np.sum(self.arrs['rho'])
		if self.has_arr['e']: e_tot0 = np.sum(self.arrs['e'])

		def update(i):

			# Run an appropriate number of simulation steps
			dt_avg = self.__step_time(t_skip)

			# Update fluid image data
			img.set_array(q() if matrixLike else q().T)

			# Update quiver plot
			if showQuiver:

				if matrixLike:

					quiver.set_UVC(self.arrs['u'][::step_q, ::step_q], self.arrs['w'][::step_q, ::step_q])

				else:

					quiver.set_UVC(self.arrs['u'][::step_q, ::step_q].T, self.arrs['w'][::step_q, ::step_q].T)

			# Update text

			textbox1.set_text('Time: %s\ndt = %.2g s' % (FluidVisualiser.__s_to_hms(self.t), dt_avg))

			if showDeviations:

				devi_text = ''
				if self.has_arr['rho']: devi_text += 'Mass deviation: %.3f %%' % (100*(np.sum(self.arrs['rho'].astype('f8'))/rho_tot0 - 1.0))
				if self.has_arr['e']: devi_text += '\nEnergy deviation: %.3f %%' % (100*(np.sum(self.arrs['e'].astype('f8'))/e_tot0 - 1.0))

				textbox2.set_text(devi_text)

			textbox3.set_text(self.param_text)

			# Print progress if generating a movie
			if save: FluidVisualiser.__print_progress(i, Nt, t0)

			# Return figure content
			return img, quiver, textbox1, textbox2, textbox3


		# *** Create animation ***

		if save:

			savename = '%s.mp4' % folder

			if self.printInfo: print 'FluidVisualiser: Generating animation ...\n'

			animation = matplotlib.animation.FuncAnimation(fig, update, blit=True, frames=Nt)

			t0 = time.time()

			animation.save(savename, writer=matplotlib.animation.FFMpegWriter(fps=30, bitrate=3200, extra_args=['-vcodec', 'libx264']))

			if self.printInfo: print '\n\nFluidVisualiser: Animation saved as \"%s\".' % savename

		else:

			if self.printInfo: print 'FluidVisualiser: Playing animation ...'

			animation = matplotlib.animation.FuncAnimation(fig, update, blit=True)
			plt.show()

	def plot_avg(self, quantity, folder='default', measure_time='auto', showTrendline=False):

		'Plots the time evolution of the average of a given quantity.'

		# *** Make sure that the inputted values are valid ***

		try:

			quantity = str(quantity)
			folder = str(folder)
			if measure_time != 'auto': measure_time = float(measure_time)

		except ValueError:

			raise ValueError('Invalid type detected among the inputted parameters.')


		# *** Check which folder to use ***

		if folder == 'default':

			if self.hasSaved:

				folder = self.folder

			else:

				raise ValueError('Name of the folder to read from must be specified unless save_data was used with this instance.')


		# *** Simulate and measure values ***

		# Read header data
		self.__read_header_data(folder)

		# Get function returning the quantity
		q, name = self.__get_quantity_info(quantity)[:2]

		# Lists for storing data points
		t_list = [self.t]
		q_list = [np.sum(q())]

		measure_time = (self.t_list[-1] - self.t_list[0]) if measure_time == 'auto' else measure_time

		# Approximate amount of time between each data point
		t_step = measure_time/500.0

		if self.printInfo: print 'FluidVisualiser: Running simulation for %g s and measuring average %s ...' % (measure_time, name)

		t0 = time.time()

		# Loop until the given time has elapsed in the simulation
		while self.t - t_list[0] < measure_time:

			# Print progress
			FluidVisualiser.__print_progress(self.t - t_list[0], measure_time, t0)

			# Advance the simulation by the time given by t_step
			self.__step_time(t_step)

			# Stop if end of files has been reached
			if self.t < t_list[-1]:

				if (measure_time - t_list[-1])/measure_time > 0.05: print '\n\nFluidVisualiser: End of files reached. Stopping measurements.'
				break

			# Store time and quantity data
			t_list.append(self.t)
			q_list.append(np.sum(q()))

		if self.printInfo: print '\n\nFluidVisualiser: Plotting time evolution of average %s ...' % name


		# *** Create and display plot ***

		delta_q = (np.array(q_list) - np.mean(q_list))/np.mean(q_list) if q_list[0] == 0 else (np.array(q_list) - q_list[0])/q_list[0]

		x_c = np.sum(t_list)/len(t_list)
		y_c = np.sum(delta_q)/len(delta_q)
		a = (y_c - delta_q[0])/x_c

		trendline = a*np.array(t_list) + delta_q[0]

		plt.plot(t_list, delta_q, 'b-', label='data')

		if showTrendline:
			plt.hold('on')
			plt.plot(t_list, trendline, 'g-', label='trend')
			plt.legend(loc='best')

		plt.title('Time evolution of average %s (relative to %s value)' % (name, 'mean' if q_list[0] == 0 else 'initial'))
		plt.xlabel('t [s]')
		plt.ylabel(r'$\Delta$ %s' % quantity)
		plt.show()

	def delete_current_data(self):

		''''
		Method for deleting the data saved by save_data (in this instance).
		'''

		if not self.hasSaved:

			print 'FluidVisualiser: Nothing to delete: no data was saved by this instance.'

		else:

			yn = raw_input('\nFluidVisualiser: Are you sure you want to delete the folder \'%s\' and all it\'s content? [Y/n] ' % (self.folder))

			while not yn.lower() in ['y', 'n']:

				print 'FluidVisualiser: Answer must be \'y\' (yes) or \'n\' (no).'
				yn = raw_input('\nFluidVisualiser: Are you sure you want to delete the folder \'%s\' and all it\'s content? [Y/n] ' % (self.folder))

			if yn.lower() == 'y':

				# Move into folder
				cwd = os.getcwd()
				newdirpath = os.path.join(cwd, self.folder)
				os.chdir(newdirpath)

				def try_remove(name):

					try:
						os.remove(name)

					except OSError:

						pass

				# Delete content
				try_remove('rho.pas')
				try_remove('u.pas')
				try_remove('w.pas')
				try_remove('e.pas')
				try_remove('P.pas')
				try_remove('T.pas')
				os.remove('time.pas')
				os.remove('info.txt')

				# Move back and delete folder
				os.chdir(cwd)
				os.rmdir(self.folder)

				print 'FluidVisualiser: All data in was \'%s\' deleted.' % (self.folder)

			else:

				print 'FluidVisualiser: No data deleted.'

	def __read_header_data(self, folder, forcedim=False, matrixLike=True):

		'Gets simulation parameters from files in a given folder.'

		# *** Move to the folder containing the binary files to read ***

		cwd = os.getcwd()
		newdirpath = os.path.join(cwd, folder)
		os.chdir(newdirpath)


		# *** Read the file containing simulation parameters ***

		f = open('info.txt', 'r')
		self.lines = f.readlines()
		f.close()

		arr_names = ['rho', 'u', 'w', 'e', 'P', 'T']
		self.has_arr = {name:bool(self.__search_info('has_' + name)) for name in arr_names}


		# *** Create _BinReader instances for reading the data ***

		self.arr_readers = {}
		self.arrs = {}

		for name in arr_names:

			if self.has_arr[name]:

				self.arr_readers[name] = _BinReader(name + '.pas')
				self.arrs[name] = None


		# *** Read the time data ***

		time_reader = _BinReader('time.pas')
		time_dat = time_reader.read_all()
		time_reader.end_read()

		self.dt_avg_list = time_dat[1:, 0]
		self.skips_list = time_dat[1:, 1]
		self.t_list = np.zeros(len(self.dt_avg_list) + 1)
		self.t_list[0] = time_dat[0, 0]
		self.t_list[1:] = self.t_list[0] + np.cumsum(self.dt_avg_list*self.skips_list)
		self.Nt = len(self.t_list)


		# *** Set fluid properties ***

		for i in xrange(len(self.lines)):

			if self.lines[i].split(' = ')[0] == 'has_T': param_start_idx = i + 1

		self.param_text = ''.join(self.lines[param_start_idx:])

		# Set initial conditons
		self.__set_initial_conditions()

		dim = len(self.arrs.values()[0].shape)

		if forcedim and forcedim != dim:

			raise ValueError('Can\'t make a %dD animation for %dD data.' %(forcedim, dim))


		# *** Set numerical quantities ***

		if dim == 2:

			self.Nx = self.arrs.values()[0].shape[1 if matrixLike else 0] 	 # Number of horizontal grid points
			self.Nz = self.arrs.values()[0].shape[0 if matrixLike else 1] 	 # Number of vertical grid points

			self.Lz = self.__search_info('Lz') 		 # Vertical length of simulation area
			self.Lx = self.__search_info('Lx')		 # Horizontal length of simulation area

			self.equal_aspect = float(self.Nx)/self.Nz


			# *** Set extent of simulation box ***

			if (self.Lx is None) or (self.Lz is None):

				self.extent_x = self.equal_aspect
				self.extent_z = 1.0

			else:

				self.extent_x = self.Lx*1e-6
				self.extent_z = self.Lz*1e-6


			# Arrays of grid points
			self.x, self.z = np.meshgrid(np.linspace(0, self.extent_x, self.Nx), np.linspace(-self.extent_z, 0, self.Nz))

		elif dim == 1:

			self.N = self.arrs.values()[0].shape[0]

			self.direction = 'z' if self.has_arr['w'] else 'x'
			self.L = self.__search_info('L%s' % (self.direction))

			self.extent = 1.0 if self.L is None else self.L*1e-6

			self.l = np.linspace(-self.extent, 0, self.N) if self.direction == 'z' else np.linspace(0, self.extent, self.N)

		else:

			raise ValueError('Invalid dimension of data files.')

		# Move back to previous working directory
		os.chdir(cwd)

	def __search_info(self, substr):

		'''
		Function for getting the value of a given parameter 
		from the lines of the "info.txt" file.
		'''

		val = None

		for line in self.lines:

			subline = line.split(' = ')

			if subline[0] == substr:

				val = float(subline[1])

		return val

	def __get_data_blocks(self, i):

		'Gets data block nr. i for each of the relevant quantities.'

		for name in self.arrs:

			self.arrs[name] = self.arr_readers[name].read_block(i)

		self.t = self.t_list[self.t_i]

	def __set_initial_conditions(self):

		'Reads the initial quantity values.'

		self.t_i = 0
		self.__get_data_blocks(self.t_i)

	def __step_time(self, min_t_skip):

		'''
		Step until a given amount of time has passed. The minimum possible 
		step time is the time between each frame in the binary files.
		'''

		# Calculate the number of steps that can be taken before the given step time is exceeded
		if min_t_skip <= self.t_list[self.t_i + 1] - self.t:

			skips = 1

		else:
			skips = np.sum(min_t_skip >= self.t_list[(self.t_i + 1):] - self.t)

		# Calculate the average time step length
		new_dt_avg = np.mean(self.dt_avg_list[self.t_i:(self.t_i + skips)])

		# Advance time
		self.t_i += skips
		if self.t_i >= self.Nt-1: self.t_i = 0

		self.__get_data_blocks(self.t_i)

		return new_dt_avg

	def __get_quantity_info(self, quantity):

		'''
		Takes a string naming a quantity and returns a function returning 
		the quantity, a string with the unit of the quantity and values for 
		the highest and lowest value of the quantity to include in the 
		visualisation.
		'''

		if quantity == 'rho':

			# Specify name of the quantity
			name = 'mass density'

			# Specify unit for the quantity
			unit = 'kg/m^3'

			# Raise error if the required data isn't available
			if not self.has_arr['rho']: raise ValueError('No visualisation data available for %s.' % name)

			# Define function returning the relevant quantity
			q = lambda: self.arrs['rho']

		elif quantity == 'drho':

			name = 'mass density contrast'
			unit = ''

			if not self.has_arr['rho']: raise ValueError('No visualisation data available for %s.' % name)

			self.rho_bg = self.arrs['rho'].copy()

			q = lambda: (self.arrs['rho'] - self.rho_bg)/self.rho_bg

		elif quantity == 'u':

			name = 'horizontal velocity'
			unit = 'm/s'

			if not self.has_arr['u']: raise ValueError('No visualisation data available for %s.' % name)

			q = lambda: self.arrs['u']

		elif quantity == 'w':

			name = 'vertical velocity'
			unit = 'm/s'

			if not self.has_arr['w']: raise ValueError('No visualisation data available for %s.' % name)

			q = lambda: self.arrs['w']

		elif quantity == 'e':

			name = 'internal energy density'
			unit = 'J/m^3'

			if not self.has_arr['e']: raise ValueError('No visualisation data available for %s.' % name)

			q = lambda: self.arrs['e']

		elif quantity == 'de':

			name = 'internal energy density contrast'
			unit = ''

			if not self.has_arr['e']: raise ValueError('No visualisation data available for %s.' % name)

			self.e_bg = self.arrs['e'].copy()

			q = lambda: (self.arrs['e'] - self.e_bg)/self.e_bg

		elif quantity == 'es':

			name = 'specific internal energy'
			unit = 'J/kg'

			if not self.has_arr['e']: raise ValueError('No visualisation data available for %s.' % name)

			q = lambda: self.arrs['e']/self.arrs['rho']

		elif quantity == 'P':

			name = 'pressure'
			unit = 'Pa'

			if not self.has_arr['P']: raise ValueError('No visualisation data available for %s.' % name)

			q = lambda: self.arrs['P']

		elif quantity == 'dP':

			name = 'pressure contrast'
			unit = ''

			if not self.has_arr['P']: raise ValueError('No visualisation data available for %s.' % name)

			self.P_bg = self.arrs['P'].copy()

			q = lambda: (self.arrs['P'] - self.P_bg)/self.P_bg

		elif quantity == 'T':

			name = 'temperature'
			unit = 'K'

			if not self.has_arr['T']: raise ValueError('No visualisation data available for %s.' % name)

			q = lambda: self.arrs['T']

		elif quantity == 'dT':

			name = 'temperature contrast'
			unit = ''

			if not self.has_arr['T']: raise ValueError('No visualisation data available for %s.' % name)

			self.T_bg = self.arrs['T'].copy()

			q = lambda: (self.arrs['T'] - self.T_bg)/self.T_bg

		elif quantity == 'v':

			name = 'speed'
			unit = 'm/s'

			if not self.has_arr['u']:

				q = lambda: np.abs(self.arrs['w'])

			elif not self.has_arr['w']:

				q = lambda: np.abs(self.arrs['u'])

			else:

				q = lambda: np.sqrt(self.arrs['u']**2 + self.arrs['w']**2)

		elif quantity == 'ru':

			name = 'horizontal momentum density'
			unit = 'kg/sm^2'

			if not self.has_arr['u']: raise ValueError('No visualisation data available for %s.' % name)

			q = lambda: self.arrs['rho']*self.arrs['u']

		elif quantity == 'rw':

			name = 'vertical momentum density'
			unit = 'kg/sm^2'

			if not self.has_arr['w']: raise ValueError('No visualisation data available for %s.' % name)

			q = lambda: self.arrs['rho']*self.arrs['w']

		elif quantity == 'rv':

			name = 'momentum density'
			unit = 'kg/sm^2'

			if not self.has_arr['u']:

				q = lambda: self.arrs['rho']*np.abs(self.arrs['w'])

			elif not self.has_arr['w']:

				q = lambda: self.arrs['rho']*np.abs(self.arrs['u'])

			else:

				q = lambda: self.arrs['rho']*np.sqrt(self.arrs['u']**2 + self.arrs['w']**2)

		elif quantity == 'eu':

			name = 'horizontal energy flux'
			unit = 'W/m^2'

			if not self.has_arr['u'] or not self.has_arr['e']: raise ValueError('No visualisation data available for %s.' % name)

			q = lambda: self.arrs['e']*self.arrs['u']

		elif quantity == 'ew':

			name = 'vertical energy flux'
			unit = 'W/m^2'

			if not self.has_arr['w'] or not self.has_arr['e']: raise ValueError('No visualisation data available for %s.' % name)

			q = lambda: self.arrs['e']*self.arrs['w']

		elif quantity == 'ev':

			name = 'energy flux'
			unit = 'W/m^2'

			if not self.has_arr['e']: raise ValueError('No visualisation data available for %s.' % name)

			if not self.has_arr['u']:

				q = lambda: self.arrs['e']*np.sqrt(self.arrs['w'])

			elif not self.has_arr['w']:

				q = lambda: self.arrs['e']*np.sqrt(self.arrs['u'])

			else:

				q = lambda: self.arrs['e']*np.sqrt(self.arrs['u']**2 + self.arrs['w']**2)

		else:

			raise ValueError('Invalid quantity.')

		if self.printInfo: print '\nFluidVisualiser: Preparing visualisation data for %s ...' % name

		return q, name, unit

	def __get_optimal_scaling(self, q, includeAll=False):

		'''
		Advances the simulation a given time and examines 
		the resulting values of a given quantity to determine the 
		optimal limit values to use in the animation. The simulation 
		is then reset.
		'''

		if self.printInfo: print 'FluidVisualiser: Finding optimal scaling ...'

		# Define lists for the extremal quantity values
		q_max = [np.max(q())]
		q_min = [np.min(q())]

		skips = int(self.Nt)/100

		if skips == 0: skips = 1

		# Advance the simulation and store extremal values
		for i in xrange(1, self.Nt, skips):

			self.__get_data_blocks(i)

			q_max.append(np.max(q()))
			q_min.append(np.min(q()))

		# Reset simulation
		self.__set_initial_conditions()

		if includeAll:

			min_val	= np.min(q_min)
			max_val = np.max(q_max)

		else:

			min_val	= np.median(q_min)
			max_val = np.median(q_max)

		return min_val, max_val

	def __get_quiver(self, ax, N_arrows, scale, showQuiver):

		'Creates a quiver object for visualising the velocity field.'

		if showQuiver:

			# Find smallest axis size
			min_N = np.min([self.Nx, self.Nz])

			# Make sure smallest number of arrows isn't larger than smallest axis size
			if N_arrows > min_N:

				N_arrows = min_N

			# Calculate number of grid points to skip in order to get the right number of arrows
			step_q = int(min_N/N_arrows)

			# Set up reduced grid
			x_q = self.x[::step_q, ::step_q]
			z_q = self.z[::step_q, ::step_q]

			# Set arrow scale so that an arrow length of 5 reduced gridpoints 
			# corresponds to a given speed based on the sound speed and a modifier.

			# If the mean sound speed can be estimated, do that (assuming gamma = 5/3)
			if (self.has_arr['P'] or self.has_arr['e']) and self.has_arr['rho']:

				cs_approx = np.mean(np.sqrt((1.67*self.arrs['P'] if self.has_arr['P'] else 1.11*self.arrs['e'])/self.arrs['rho']))

			# Otherwise use an arbitrary value
			else:

				cs_approx = 17000.0

			arrscale = 0.2*N_arrows*cs_approx/scale

			# Create quiver plot
			quiver = ax.quiver(x_q, z_q, x_q, z_q, units='height', scale=arrscale, width=0.003, color='k')

			# Add text with arrow scale
			arrowtext = 'Arrow scale = %g (m/s)/Mm' % (arrscale/self.extent_z)

			ax.text(0.995, 1.005, arrowtext, color='k', fontsize=11, horizontalalignment='right', 
										     verticalalignment='bottom', transform=ax.transAxes)

		else:

			# Create a dummy quiver plot that doesn't show in the animation

			step_q = 0
			quiver = ax.quiver([-10], [10], [-1], [1])

		return step_q, quiver

	def __prepare_text(self, ax, dim=2):

		'Sets up textboxes for updateable info.'

		# Create textboxes for displaying updateable information
		textbox1 = ax.text(0.01, 0.97, '', color='k', fontsize=11, horizontalalignment='left', 
									   	   verticalalignment='top', transform=ax.transAxes)

		textbox2 = ax.text(0.99, 0.97, '', color='k', fontsize=11, horizontalalignment='right', 
									   	  verticalalignment='top', transform=ax.transAxes)

		textbox3 = ax.text(0.01, 0.03, '', color='k', fontsize=11, horizontalalignment='left', 
									   	   verticalalignment='bottom', transform=ax.transAxes)

		# Display number of data points above the animation

		if dim == 2:

			ax.text(0.005, 1.005, 'Nx = %d, Nz = %d' % (self.Nx, self.Nz), color='k', fontsize=11, horizontalalignment='left', 
										     							   verticalalignment='bottom', transform=ax.transAxes)

		elif dim == 1:

			ax.text(0.005, 1.005, 'N = %d' % (self.N), color='k', fontsize=11, horizontalalignment='left', 
										     		   verticalalignment='bottom', transform=ax.transAxes)

		else:

			raise ValueError('Invalid dimension.')

		return textbox1, textbox2, textbox3

	@staticmethod
	def __s_to_hms(t_s):

		'Convert a time in seconds to a string showing hours, minutes and seconds.'

		hours = t_s/3600.0
		minutes = 60*(hours - int(hours))
		seconds = 60*(minutes - int(minutes))

		return '%02d:%02d:%02d' % (hours, minutes, seconds)

	@staticmethod
	def __print_progress(i, N, t0):

		'Prints progress info.'

		progress = i*100.0/N
		elapsed = time.time() - t0
		if progress >= 5: ETA = (100/progress - 1)*elapsed

		sys.stdout.write('Progress: %.1f%% | Elapsed: %s%s \r' % (progress, FluidVisualiser.__s_to_hms(elapsed), '' if progress < 5 else (' | ETA: %s' % FluidVisualiser.__s_to_hms(ETA))))
		sys.stdout.flush()


class _BinWriter:

	'''
	Class for writing array data of arbitrary dimensionality to a binary file.
	'''

	def __init__(self, filename, block_shape, dtype_dbytes):

		'''
		Opens binary file and writes a header. The header consists of the following entries:
	
		block_dim: 						       Number of dimensions of the data block arrays
		block_num:						       Total number of data blocks in the body
		block_shape[0], ... , block_shape[-1]: Number of elements along each dimension of a data block
		dtype:								   Character indicating the data type of the elements in a data block
		dbytes:								   Number of bytes used by an element in a data block
		packtype:							   Character indicating the way the arrays have been flattened
											   ("F": Fortran style, "C": C++ style)

		All header entries are 32 bit integers except dtype and packtype, which are 8 bit characters.
		'''

		self.block_shape = np.asarray(block_shape, dtype='i4') # Set data block shape
		self.dtype_dbytes = dtype_dbytes		     	       # Set element data type and precision

		self.block_num = 0	       					# Set counter to zero
		self.write_time = 0		   					# Set total writing time to zero

		# Make sure that the correct file extension is used

		fn_ext = '' if not '.' in filename else filename.split('.')[1]
		fn_noext = filename.split('.')[0]

		if len(fn_ext) > 0:

			if fn_ext != 'pas':

				print '_BinWriter warning (\"%s\"): Invalid file extension. Using \".pas\" instead.' \
					  % filename

		self.filename = fn_noext + '.pas'

		# Check that the input string specifying the data type and precision is complete

		if len(dtype_dbytes) < 2:

			print '_BinWriter error (\"%s\"): Invalid input \"%s\" for data type/precision. ' % (self.filename, dtype_dbytes) \
				  + 'Must be a string consisting of a letter (describing the type) followed ' \
				  + 'by a number (describing the precision), e.g. "i4" for the 4 byte signed integer type.'
			sys.exit()

		try:

			self.dtype = dtype_dbytes[0]
			self.dbytes = int(dtype_dbytes[1:])

		except ValueError:

			print '_BinWriter error (\"%s\"): Invalid input \"%s\" for data type/precision. ' % (self.filename, dtype_dbytes) \
				  + 'The part following \"%s\" must be a number.' % (dtype_dbytes[0])
			sys.exit()

		# Make sure that the specified data type and precision is valid

		if not self.dtype in ['S', 'i', 'f', 'u', 'c']:

			print '_BinWriter error (\"%s\"): Invalid data type (\"%s\") . ' % (self.filename, self.dtype) \
				  + 'Valid types are \"S\" (character), \"i\" (signed integer), \"f\" (float), \"u\" (unsigned integer) and \"c\" (complex).'
			sys.exit()

		if self.dtype == 'S' and self.dbytes != 1:

			print '_BinWriter error (\"%s\"): Invalid data precision (%d bytes) for character type. ' % (self.filename, self.dbytes) \
				  + 'The only valid precision is 1 byte.'
			sys.exit()

		elif self.dtype == 'i' and not self.dbytes in [1, 2, 4, 8]:

			print '_BinWriter error (\"%s\"): Invalid data precision (%d bytes) for signed integer type. ' % (self.filename, self.dbytes) \
				  + 'Valid precisions are 1, 2, 4 and 8 bytes.'
			sys.exit()

		elif self.dtype == 'f' and not self.dbytes in [2, 4, 8]:

			print '_BinWriter error (\"%s\"): Invalid data precision (%d bytes) for float type. ' % (self.filename, self.dbytes) \
				  + 'Valid precisions are 2, 4 and 8 bytes.'
			sys.exit()

		elif self.dtype == 'u' and not self.dbytes in [1, 2, 4, 8]:

			print '_BinWriter error (\"%s\"): Invalid data precision (%d bytes) for unsigned integer type. ' % (self.filename, self.dbytes) \
				  + 'Valid precisions are 1, 2, 4 and 8 bytes.'
			sys.exit()

		elif self.dtype == 'c' and not self.dbytes in [8, 16]:

			print '_BinWriter error (\"%s\"): Invalid data precision (%d bytes) for complex type. ' % (self.filename, self.dbytes) \
				  + 'Valid precisions are 8 and 16 bytes.'
			sys.exit()

		# Block array dimension
		self.block_dim = len(self.block_shape)

		# Start measuring time
		self.start_time = time.time()

		# Open binary file for writing output
		self.f = open(self.filename, 'wb')

		# Write first header entry
		self.f.write(struct.pack('i4', self.block_dim))

		# Skip second header entry (not yet determined)
		self.f.seek(8, os.SEEK_SET)

		# Write remaining header entries
		self.block_shape.tofile(self.f, sep='')
		self.f.write(struct.pack('c1', self.dtype))
		self.f.write(struct.pack('i4', self.dbytes))
		self.f.write(struct.pack('c1', 'C'))

	def write_block(self, block):

		'Adds a data block to the end of the file.'

		# Get initial time
		t0 = time.time()

		# Write data block
		np.asarray(block, dtype=self.dtype_dbytes).tofile(self.f, sep='')

		# Add elapsed time to total time
		self.write_time += time.time() - t0

		# Increase counter
		self.block_num += 1

	def print_header_info(self):

		print '\n*** Header info for \"%s\" ***' % (self.filename)
		print 'Data block dimension:: %dD' % (self.block_dim)
		print 'Total number of data blocks: %d' % (self.block_num)
		print 'Data block shape: ' + _Common.get_shape_string(self.block_shape, useParan=True)
		print 'Data type: ' + _Common.dtype_descript[self.dtype]
		print 'Number of bytes per element: %d' % (self.dbytes)
		print 'Pack type: C++/Python style'

		print 'I live in _BinWriter!'

	def end_write(self, printReport=False):

		'Adds the second header number, closes the file and prints writing info.'

		# Go to second header number
		self.f.seek(4, os.SEEK_SET)

		# Write number of blocks written
		self.f.write(struct.pack('i4', self.block_num))

		# Close file
		self.f.close()

		# Stop measuring time
		self.stop_time = time.time()

		if printReport:

			# Print title
			print '\n*** Writing report for \"%s\" ***' % (self.filename)

			# Print block info
			print 'Data blocks: %s %s (%d bit precision)' % (_Common.get_shape_string(self.block_shape), 
															 _Common.dtype_descript[self.dtype], 
															 8*self.dbytes)

			# Print number of blocks written
			print 'Number of blocks written: %d' % self.block_num

			# Print total amount of data written
			tot_size = self.dbytes*self.block_num*np.prod(self.block_shape.astype('i8'))/1024000.0
			print 'Amount of data written: %g MB' % tot_size

			if self.write_time != 0:

				# Print writing time
				print 'Total writing time: %g s' % (self.write_time)

				# Print writing speed
				print 'Average writing speed: %.3g MB/s' % (tot_size/self.write_time)

			# Print amount of time file was open for
			print 'File open for: %.3g s' % (self.stop_time - self.start_time)


class _BinReader:

	'''
	Class for reading binary files.
	'''

	def __init__(self, filename):

		'''
		Opens file and reads header.
		'''

		# Make sure that the correct file extension is used

		fn_ext = '' if not '.' in filename else filename.split('.')[1]
		fn_noext = filename.split('.')[0]

		if len(fn_ext) > 0:

			if fn_ext != 'pas':

				print '_BinReader error (\"%s\"): Invalid file extension. Can only read \".pas\" files.' \
					  % filename
				sys.exit()

		else:

			print '_BinReader warning (\"%s\"): No file extension supplied. Assuming extension is \".pas\".' % filename

		self.filename = fn_noext + '.pas'

		# Start measuring time
		self.start_time = time.time()

		# Open binary file
		self.f = open(self.filename, 'rb')

		# Read array dimensions from header
		self.block_dim = int(np.fromfile(self.f, count=1, dtype='i4'))

		# Move read indicator to next header entry
		self.f.seek(4, os.SEEK_SET)

		# Read array shape numbers
		self.body_shape = np.fromfile(self.f, count=(self.block_dim + 1), dtype='i4')

		# Move read indicator to next header entry
		self.f.seek(4*(self.block_dim + 2), os.SEEK_SET)

		# Read element data type
		self.dtype = str(np.fromfile(self.f, count=1, dtype='a1')[0])

		# Move read indicator to next header entry
		self.f.seek(4*(self.block_dim + 2) + 1, os.SEEK_SET)

		# Read element precision (number of bytes for each element)
		self.dbytes = int(np.fromfile(self.f, count=1, dtype='i4'))

		# Move read indicator to final header entry
		self.f.seek(4*(self.block_dim + 3) + 1, os.SEEK_SET)

		# Read pack type
		self.packtype = str(np.fromfile(self.f, count=1, dtype='a1')[0])

		# Print error and abort if the data type or precision in the file cannot be read

		if not self.dtype in ['S', 'i', 'f', 'u', 'c']:

			print '_BinReader error (\"%s\"): Cannot read the data type of this file (\"%s\") . ' % (self.filename, self.dtype) \
				  + 'Can only read \"S\" (character), \"i\" (signed integer), \"f\" (float), \"u\" (unsigned integer) and \"c\" (complex).'
			self.f.close()
			sys.exit()

		if self.dtype == 'S' and self.dbytes != 1:

			print '_BinReader error (\"%s\"): Cannot read the data precision of this file (%d byte). ' % (self.filename, self.dbytes) \
				  + 'Can only read 1 byte precision for character type.'
			self.f.close()
			sys.exit()

		elif self.dtype == 'i' and not self.dbytes in [1, 2, 4, 8]:

			print '_BinReader error (\"%s\"): Cannot read the data precision of this file (%d byte). ' % (self.filename, self.dbytes) \
				  + 'Can only read 1, 2, 4 and 8 byte precision for signed integer type.'
			self.f.close()
			sys.exit()

		elif self.dtype == 'f' and not self.dbytes in [2, 4, 8]:

			print '_BinReader error (\"%s\"): Cannot read the data precision of this file (%d byte). ' % (self.filename, self.dbytes) \
				  + 'Can only read 2, 4 and 8 byte precision for float type.'
			self.f.close()
			sys.exit()

		elif self.dtype == 'u' and not self.dbytes in [1, 2, 4, 8]:

			print '_BinReader error (\"%s\"): Cannot read the data precision of this file (%d byte). ' % (self.filename, self.dbytes) \
				  + 'Can only read 1, 2, 4 and 8 byte precision for unsigned integer type.'
			self.f.close()
			sys.exit()

		elif self.dtype == 'c' and not self.dbytes in [8, 16]:

			print '_BinReader error (\"%s\"): Cannot read the data precision of this file (%d byte). ' % (self.filename, self.dbytes) \
				  + 'Can only read 8 and 16 byte precision for complex type.'
			self.f.close()
			sys.exit()

		# Print warning if the stated pack type is unknown

		if not self.packtype.upper() in ['C', 'F']:

			print '_BinReader warning (\"%s\"): Pack type \"%s\" not recognized. Assuming C++/Python style flattening.' \
				  % self.packtype

		self.dtype_dbytes = self.dtype + ('%d' % self.dbytes)   # Data type and precision in body array
		self.start = 4*(self.block_dim + 3) + 2 		        # Position of first value in body
		self.block_shape = self.body_shape[1:] 			        # Shape of the data blocks
		self.block_num = self.body_shape[0]				        # Total number of data blocks
		self.block_len = np.prod(self.block_shape.astype('i8')) # Number of elements in each data block
		self.block_size = self.dbytes*self.block_len		    # Number of bytes in each data block

		self.read_count = 0
		self.read_time = 0

	def read_all(self):

		'''
		Reads the entire body array and stores the array in an attribute.
		'''

		# Move read indicator to beginning of body
		self.f.seek(self.start, os.SEEK_SET)

		try:

			# Get initial time
			t0 = time.time()

			# Create array containing all the body data
			data = np.fromfile(self.f, dtype=self.dtype_dbytes)

			# Reshape array
			if self.block_num == 1:

				data = data.reshape(self.block_shape, order=self.packtype)

			else:

				data = data.reshape(self.body_shape, order=self.packtype)

		except IOError:

			print '_BinReader error (\"%s\"): File is too large to read all at once. Read in blocks instead.' \
				   % (self.filename)
			self.f.close()
			sys.exit()

		# Add elapsed time to total time
		self.read_time += time.time() - t0

		# Set number of blocks read
		self.read_count = self.block_num

		return data

	def read_block(self, i):

		'''
		Reads block nr. i of the body array and stores the array in an attribute.
		'''

		# Move read indicator to beginning of data block i
		self.f.seek(self.start + i*self.block_size, os.SEEK_SET)

		# Get initial time
		t0 = time.time()

		# Create array containing data in block i
		data = np.fromfile(self.f, count=self.block_len, dtype=self.dtype_dbytes).reshape(self.block_shape, order=self.packtype)

		# Add elapsed time to total time
		self.read_time += time.time() - t0

		# Increase counter
		self.read_count += 1

		return data

	def print_header_info(self):

		print '\n*** Header info for \"%s\" ***' % (self.filename)
		print 'Data block dimension: %dD' % (self.block_dim)
		print 'Total number of data blocks: %d' % (self.block_num)
		print 'Data block shape: ' + _Common.get_shape_string(self.block_shape, useParan=True)
		print 'Data type: ' + _Common.dtype_descript[self.dtype]
		print 'Number of bytes per element: %d' % (self.dbytes)
		print 'Pack type: ' + ('Fortran style' if self.packtype.upper() == 'F' else 'C++/Python style')

		print 'I live in _BinReader!'

	def end_read(self, printReport=False):

		'''
		Closes the file and prints reading info.
		'''

		# Close file
		self.f.close()

		# Stop measuring time
		self.stop_time = time.time()

		if printReport:

			# Print title
			print '\n*** Reading report for \"%s\" ***' % (self.filename)

			# Print block info
			print 'Data blocks: %s %s (%d bit precision)' % (_Common.get_shape_string(self.block_shape), 
															 _Common.dtype_descript[self.dtype], 
															 8*self.dbytes)

			# Print number of blocks read
			print 'Number of blocks read: %d/%d' % (self.read_count, self.block_num)

			# Print amount of data read
			read_size = self.read_count*self.block_size/1024000.0
			tot_size = self.block_num*self.block_size/1024000.0
			print 'Amount of data read: %g/%g MB' % (read_size, tot_size)

			if self.read_time != 0:

				# Print reading time
				print 'Total reading time: %g s' % (self.read_time)

				# Print reading speed
				print 'Average reading speed: %g MB/s' % (read_size/self.read_time)

			# Print amount of time file was open for
			print 'File open for: %.3g s' % (self.stop_time - self.start_time)


class _Restrictor:

	'''
	Class for overwriting some methods from _BinWriter and _BinReader 
	to prevent them from being called from a _BinAppender instance.
	'''

	def end_write(self, printReport=False):

		raise AttributeError

	def read_all(self):

		raise AttributeError

	def read_block(self, i):

		raise AttributeError

	def end_read(self, printReport=False):

		raise AttributeError


class _BinAppender(_Restrictor, _BinWriter, _BinReader):

	'''
	Class for appending array data of arbitrary dimensionality to 
	a binary file. Data blocks can be appended by calling the 
	method "write_block", inherited from the _BinWriter class.
	'''

	def __init__(self, filename, block_shape, dtype_dbytes):

		'Opens a binary file, reads the header and prepares to append data to the file.'

		# Call constructor of the writing class to get header data
		_BinReader.__init__(self, filename)

		# Close the file (which is opened in reading mode)
		self.f.close()

		# Check that the data to append has the same format as the existing data

		if (np.asarray(block_shape, dtype='i4') != self.block_shape).any():

			print '_BinAppender error (\"%s\"): Input block shape [%s] must match that of the blocks already written to the file [%s].' \
				  % (self.filename, _Common.get_shape_string(np.asarray(block_shape, dtype='i4')), self.block_shape)
			sys.exit()

		if dtype_dbytes != self.dtype_dbytes:

			print '_BinAppender error (\"%s\"): Input data type and precision (\"%s\") must match that of the blocks already written to the file (\"%s\").' \
				  % (self.filename, dtype_dbytes, self.dtype_dbytes)
			sys.exit()

		if self.packtype.upper() != 'C':

			print '_BinAppender error (\"%s\"): Pack type of file to append to must be C++/Python style.' % (self.filename)
			sys.exit()

		# Start measuring time
		self.start_time = time.time()

		# Open the file in append mode
		self.f = open(self.filename, 'ab')

		self.write_time = 0
		self.block_num_orig = self.block_num
		self.block_num = 0

	def end_append(self, printReport=False):

		'Updates the second header number, closes the file and prints writing info.'

		# Close the file (which is in append mode)
		self.f.close()

		# Stop measuring time
		self.stop_time = time.time()

		# Reopen the file in a mode that permits overwriting
		self.f = open(self.filename, 'r+b')

		# Go to second header number
		self.f.seek(4, os.SEEK_SET)

		# Update total number of blocks written
		self.f.write(struct.pack('i4', self.block_num_orig + self.block_num))

		# Close file
		self.f.close()

		if printReport:

			# Print title
			print '\n*** Writing report for \"%s\" (append mode) ***' % (self.filename)

			# Print block info
			print 'Data blocks: %s %s (%d bit precision)' % (_Common.get_shape_string(self.block_shape), 
															 _Common.dtype_descript[self.dtype], 
															 8*self.dbytes)

			# Print number of blocks appended
			print 'Number of blocks appended: %d (total is now %d)' % (self.block_num, 
																	   self.block_num + self.block_num_orig)

			# Print total amount of data appended
			block_size_MB = self.dbytes*np.prod(self.block_shape.astype('i8'))/1024000.0
			tot_size = self.block_num*block_size_MB
			print 'Amount of data appended: %g MB (total is now %g)' % (tot_size, 
																		tot_size + self.block_num_orig*block_size_MB)

			if self.write_time != 0:

				# Print writing time
				print 'Total writing time: %g s' % (self.write_time)

				# Print writing speed
				print 'Average writing speed: %.3g MB/s' % (tot_size/self.write_time)

			# Print amount of time file was open for
			print 'File open for: %.3g s' % (self.stop_time - self.start_time)


class _Common:

	'Namespace available to all the classes in this module.'

	# Dictionary with type descriptions
	dtype_descript = {'S':'character', 'i':'signed integer', 'f':'float', 'u':'unsigned integer', 'c':'complex'}

	@staticmethod
	def get_shape_string(arr, useParan=False):

		'Returns a pretty string representation of an input 1D array.'

		symb = ', ' if useParan else ' x '

		arr_str = '%d' % (arr[0])

		for val in arr[1:]:
			arr_str += '%s%d' % (symb, val)

		if useParan: arr_str = '(' + arr_str + ')'

		return arr_str